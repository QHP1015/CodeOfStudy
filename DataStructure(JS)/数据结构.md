## 栈

- 创建栈类

  ```js
  class Stack{
      // 栈中的属性
      constructor() { this.items = [] }
  
  	// 栈相关的方法
  	// 入栈操作
  	push(element) {
          this.items.push(element)
  	}
  
  	// 出栈操作
  	pop(element) {
     		return this.items.pop()	// 从数组中删除最后一个元素, 并且将该元素返回
  	}
  
  	// 查看栈顶元素操作
  	peek() {
      	return this.items[items.length - 1]
  	}
  
  	// 判断栈中的元素是否为空
  	isEmpty() {
      	return this.items.length === 0	// 判断数组中的元素个数是否为0, 为0返回true, 否则返回false
  	}
  
  	// 获取栈中元素的个数
  	size() {
      	return this.items.length
  	}
      
  	// 清空栈
  	clear() {
  		this.items = []
  	}
  }
  ```

  

## 队列

- 创建队列类

  ```js
  class Queue {
      constructor() {
          this.items = []
      }
      // 入队操作
      enQueue(element) {
          this.items.push(element)
      }
      
      // 出队操作
      deQueue() {
          return this.items.shift()
      }
      
      // 查看队头元素
      front() {
          return this.items[0]
      }
      
      // 判断队列是否为空
      isEmpty() {
          return this.items.length === 0
      }
      
      // 查看队列种元素个数
      size() {
          return this.items.length
      }
      
      // toString
      toString() {
          return this.items.join(',')
      }
  }
  ```

- 优先级队列

  ```js
  class QueueElement {
  	constructor(element, priority) {
  		this.element = element	    //队列的元素
      	this.priority = priority	//优先级
  	}
  }
  class PriorityQueue {
  	constructor() {
  	this.items = []
  	}
  
      // 入队操作
  	enqueue(element, priority) {
      	let queueElement = new QueueElement(element, priority)
      	let added = false
      	for (let i = 0; i < this.items.length; i++) {
  			// 当找到一个比要添加的元素的优先级更高的项时，将新元素插入到它之前。
  				if (queueElement.priority < this.items[i].priority) {
  					this.items.splice(i, 0, queueElement) // 插入新元素
  					added = true
  					break // 终止队列循环
  				}
  		}	
  		// 当需要添加的元素优先级大于队列中的任何一个元素的时候，把该元素添加到队尾。
  		if (!added) {
  			this.items.push(queueElement)
  		}
  	}
      
      // 出队操作
  	dequeue() {
      // 根据队列的先进先出原则，使用shift方法
      // shift方法会从数组中移除存储在索引为0的元素
  		return this.items.shift()
  	}
  	
      // 查看队列元素
  	front() {
      	return this.items[0]
  	}
  
      // 判断队列是否为空
      isEmpty() {
      	return this.items.length === 0
  	}
  
      // 查看队列种元素个数
      size() {
  		return this.items.length
  	}
  
      // 队列内容字符串化
  	toString() {
  		return this.items.toString()
  	}
  }
  ```



## 链表

- 创建链表类

  ```js
  class Node {
  	constructor (value) {
      	this.value = value;
      	this.next = null;
  	}
  }
  
  class LinkedList {
  	constructor () {
      	this.head = null;
      	this.tail = this.head;
     		this.length = 0;
  	}
    
      // 在末尾添加节点
    	append (value) {
  		const newNode = new Node(value)
  		if (!this.head) {
  			this.head = newNode;
  			this.tail = newNode;
  		} else {
  			this.tail.next = newNode;
  			this.tail = newNode;
  		}
  		this.length++;
  	}
  
      // 在开头添加节点
  	prepend (value) {
  		const node = new Node(value);
  		node.next = this.head;
  		this.head = node;
  		this.length++;
      }
  
      // 在特定索引处添加值
  	insert (value, index) {
          if (index >= this.length) {
  			this.append(value);
  		}
          const node = new Node(value);
          const { prevNode, nextNode } = this.getPrevNextNodes(index);
          prevNode.next = node;
          node.next = nextNode;
          this.length++;
      }
      // getPrevNextNodes函数：通过遍历链表返回在 index-1 位置和 index 位置的节点，并将 prevNode 的 next 属性指向新节							 点，并将新节点的 next 属性指向 nextNode
      getPrevNextNodes(index){ 
      	let count = 0;
      	let prevNode = this.head;
      	let nextNode = prevNode.next;
  
      	while(count < index - 1){
  			prevNode = prevNode.next;
  			nextNode = prevNode.next;
  			count++;
  		}
  		return { prevNode, nextNode};
  	}
  
      // 删除特定索引处的元素
  	remove (index) {
          let {previousNode,currentNode} = this.getPrevNextNodes(index);
  		previousNode.next = currentNode.next;
          this.length--;
  	}
      
      // 反转链表
      reverse () {
          let previousNode = null;
  		let currentNode = this.head;
  
  		while(currentNode !== null) {
  			let nextNode = currentNode.next;
  			currentNode.next = previousNode;
  			previousNode = currentNode;
              currentNode = nextNode;
          }
          this.head = previousNode;
      }
      
      // 查找特定索引的值
      lookup (index) {
          let counter = 0;
      	let currentNode = this.head;
      	while(counter < index){
              currentNode = currentNode.next;
              counter++;
          }
          return currentNode;
      }
  }
  ```
  
  